<!DOCTYPE html>
<html lang="en">
<head>
	<title>WDD 330 - Week 7 - Notes</title>

	<link rel="stylesheet" href="../css/main.css">

</head>

<body>
    <h1>Week 7 - Notes</h1>

    <h2>Notes:</h2>
    <h3>Further functions</h3>
    <p>
        Functions have properties and Methods:
    </p>
    <ul>
        <li>The <span class="bold">length</span> property returns the number of paramenters function acepts: <code>functionName.length</code></li>
        <li>The <span class="bold">call()</span> method sets the value of <code>this</code> inside a function: <code>functionName.call({a=1}, param1)</code></li>
        <li>The <span class="bold">apply()</span> method is similar to <code>call()</code> but paraments are passed as array: functionName.apply(null, [4]) </li>
        <li><span class="bold">Custom properties</span> can be addded like any other object function: <code>functionName.description = 'description of function'</code></li>
        <li>The <span class="bold">memorization</span> feature is for caching a result:<code>functionName.cache[x]</code>  </li>
    </ul>
    <p>
        <span class="bold">Immediately Invoked Function Expression</span> are anonymous functions that are invoked as soon as they are defined. 
        This technique can be used to nitialize code or for temporary variables
    </p>
    <p class="code">
        <code>
            (function(){
            const temp = 'World';
            console.log(`Hello ${temp}`);
            })();
        </code>
    </p>
    <p>
        <span class="bold">Strict mode</span> dan be used inside a function and only the IIFE will be affected.
    </p>
    <p>
        Functions  can also rewrite themselves:
    </p>
    <p class="code">
        <code>
            function party(){
            console.log('Wow this is amazing!');
            party = function(){
            console.log('Been there, got the T-Shirt');
            }
            }
            // calling the function
            party();
            << 'Wow this is amazing!'
            party();
            << 'Been there, got the T-Shirt'
            party();
            << 'Been there, got the T-Shirt'
        </code>
    </p>
    <p>
        <span class="bold">Call backs</span> are used to facilitate event-driven asynchronous programming.
        The increase in the use of asynchronous programming in JavaScript has meant
        that more and more callbacks are being used. This can result in messy and
        confusing “spaghetti code”.
    </p>
    <p>
        A <span class="bold">promise</span> represents the future result of an asynchronous operation, they don’t do anything that can’t already be achieved using callbacks, but they help
        simplify the process, and avoid the convoluted code that can result from using multiple callbacks.
        When a promise is created, it calls an asynchronous operation and is then said to be pending, the promise is said to be unsettled. Once the operation has completed, the
        promise is said to have been settled. A settled promise can result in two different
        outcomes:
          <ul>
              <li>Resolved ― the asynchronous operation was completed successfully.</li>
              <li>Rejected ― the asynchronous operation didn’t work as expected, wasn’t successfully completed or resulted in an error.</li>
          </ul>
       The general layout of a promise is
    </p>
    <p class="code">
        <code>
            const promise = new Promise( (resolve, reject) => {
              // initialization code goes here
              if (success) {
                resolve(value);
              } else {
                reject(error);
              }
              }
            });
        </code>
    </p>
    <p>
        A <span class="bold">pure function </span> is a function that adheres to the following rules:
          <ul>
              <li>
                  The return value of a pure function should only depend on the values
                  provided as arguments. It doesn’t rely on values from somewhere else in the
                  program
              </li>
              <li>
                  There are no side-effects. A pure function doesn’t change any values or data
                  elsewhere in the program. It only makes non-destructive data transformations and
                  returns new values, rather than altering any of the underlying data.
              </li>
              <li>
                  Referential transparency. Given the same arguments, a pure function will
                  always return the same result.
              </li>
          </ul>
    </p>
    <p>
       
            Currying is a process that involves the partial application of functions.A function is said to be curried when not all arguments have been supplied to the
            function, so it returns another function that retains the arguments already
            provided, and expects the remaining arguments that were omitted when the
            original function was called.
            Currying relies on higher-order functions that are able to return partially applied
            functions
    </p>

    <h4>Ajax</h4>
    <p>
        Ajax is a technique that allows web pages to communicate asynchronously with a
        server, and it dynamically updates web pages without reloading.
    </p>
    <p>
        The Fetch API provides a global fetch() method that only has one mandatory
        argument, which is the URL of the resource you wish to fetch.
    </p>
    <p class="code"><code>
    fetch('https://example.com/data')
    .then( // code that handles the response )
    .catch( // code that runs if the server returns an error )


    fetch(url)
    .then((response) => {
        if(response.ok) {
            return response;
        }
        throw Error(response.statusText);
    })
    .then( response => // do something with response )
    .catch( error => console.log('There was an error!') )

</code>
    </p>
    <p>
        Some other properties of the Response object are:
        <ul>
            <li>
                headers – A Headers object (see later section) containing any headers
                associated with the response
            </li>
            <li>url – A string containing the URL of response</li>
            <li>
                redirected – A boolean value that specifies if the response is the result of a
                redirect
            </li>
            <li>
                type – A string value of “basic”, “cors”, “error” or “opaque”. A value of
                “basic” is used for a response from the same domain.
            </li>
        </ul>
    </p>

    <p>
        The response object also contains a number of methods that return promises that
        can then be chained together
    </p>
    <p>
        The <span class="bold">redirect()</span> method can be used to redirect to another URL. It creates a new
        promise that resolves to the response from the redirected URL.

    </p>
    <!--<p class="code">
        <code>
            const error = new Error();

            const error = new Error('Oops, something went wrong');

        </code>
    </p>
    <p>There are seven more error objects for specific errors:</p>
    <ul>
        <li>EvalError error using global eval() function.</li>
        <li>RangeError is thrown when a number is outside an allowable range of values</li>
        <li>ReferenceError is thrown when a reference is made to an item that doesn’t exist.</li>
        <li>SyntaxError is thrown when there’s an error in the code’s syntax.</li>
        <li>TypeError is thrown when there’s an error in the type of value used; for example, a string is used when a number is expected.</li>
        <li>URIError is thrown when there’s a problem encoding or decoding the URI.</li>
        <li> InternalError is a non-standard error that is thrown when an error occurs in the JavaScript engine. A common cause of this too much recursion.        </li>
    </ul>
    <h3>Throwing Exceptions</h3>
    <p>
        The throw statement can be applied to any JavaScript expression, causing the
        execution of the program to stop
    </p>
    <p class="code">
        <code>
            throw 2;
            throw 'Up';
            throw { toys: 'out of pram' };
            throw new Error('Something has gone badly wrong!'); // Best practice
        </code>
    </p>

    <h3>
        Exception Handling - try, catch, and finally
    </h3>
    <p>
        The try block will run the code inside as normal, but if an exception
        occurs it will pass the error object that is thrown onto a catch block.
        The error object is automatically passed as a parameter to the catch block.
        A finally block can be added after a catch block.
    </p>
    <h3>Tests</h3>
    <p>
        <span class="bold">Test-driven Development (TDD)</span> is the process of writing tests before any actual code.he following workflow:
    </p>
    <ol>
        <li>Write tests (that initially fail)</li>
        <li>Write code to pass the tests</li>
        <li>Refactor the code</li>
        <li>Test refactored code</li>
        <li>Write more tests for new features</li>
    </ol>
    <p>Jest is a popular TDD framework </p>-->
    <hr />
    <h2>Exercises:</h2>
    <ol>
        <li><a href="../week5/team-activity/index.html">Team Activity</a></li>
        <!--<li><a href="debugger.html">Use of debugger keyword </a></li>-->
        <!--<li><a href="groups.html">JavaScript List class that can be constructed using an array as parameter and has a static method</a></li>-->
    </ol>
    <hr />
    <h2>Questions:</h2>

    <ul>
        <!--<li></li>-->
    </ul>
</body>
</html>